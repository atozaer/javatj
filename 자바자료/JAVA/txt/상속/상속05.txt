자 함수재정의에서부터 가상메서드를 잠깐 말씀을 드릴텐데 그거 말씀드리기 전에 우리가 메서드호출이 어떻게

되는지 사실 메서드는 함수의 일종이죠 함수호출이 어떻게 되는지 잠깐 말씀을 드리도록 하겠습니다.

빈공간에다가 그림을 그리면서 설명을 드리도록 하겠습니다.

우리가 코드가 있잖아요 프로그램안에는 코드들이 있어요 그래서 어떤 함수가 있지요 a()라는 함수가 있고

이 함수가 쓰는 변수들이 있을 것이고 이안에 인스트럭션 명령어들이 죽 있을 겁니다. 인스트럭션 셋이라고 우리가

이야기 하는데 그러면 그 함수 이름 a는 나중에 컴파일이 되면 우리가 a라는 함수를 호출을 하잖아요 a라는 함수가

호출이되는데 그러면 이프로그램이 로드가 되면 메모리에 올라가면 프로그램을 더블클릭해서 애를 실행을 시키게  

되면 여기 뭐 static변수도 있고 뭐 인티저 상수도 있고 그런데 이런값들이 메모리에 올라가게 되면은 크게 두가지

영역으로 나뉘는데 하나는 코드 영역이구요 하나는 데이터영역이에요 데이터영역을 상수영역이라고도 하고 스태틱

영역이라고 한다고 말씀을 드렸고 Data영역은 스태틱이나 리터럴들 전부 Data영역에 잡힌다고 말씀을 드렸고 

코드영역이 뭐냐 코드영역에는 뭐가 만들어지냐면 어 코드영역에는  우리가 만든 프로그램의 a라는 메서드들 있죠

함수들이 코드영역에 들어갑니다. 우리가 함수안에는 여러가지 다른함수를 부르는 기능 출력하는기능 여러가지 

기능이 있구요 더한다 이변수랑  이변수랑 더한다. 이런 기능들이 있는데 이런 더하는기능이라는거는 인스턴스마다

다르지가 않아요 에이라는 인스턴스랑 비라는 인스턴스랑 두개의 인스턴스가 있다라고 했을때 두개의 인스턴스에

더하는 기능이다라는건 다르지가 않거든요 뭐가 다르냐면 변수가 다른거죠 변수가 근데 변수의 영역은 따로 잡혀요 

말씀드렸듯이 변수는 지역변수인경우는 stack스택에 잡히고 인스턴스인경우는 힙에 잡히죠 그죠 우리가 저번에 

변수와 변수의 영역들 static하면서 예기를 쭉 했습니다. 라이프스코프범위까지 그러면 이 기능이라는 부분

각각 다른함수를 호출을 한다라든가 여기서 뭐를 해라라는 인스트럭션이라는 부분은 인스턴스마다 다르지 않다

라는 거에요 그렇기 때문에 요 인스트럭션 셋은 이 코드영역이라는 곳에 잡히고 이쪽에 a라고 호출을 하면 

a는 함수의 이름은 나중에 어드레스라는것으로 변환이 됩니다. 그래서 우리가 배열의 이름과 함수의 이름은 

주소다라고 이야기를 하는데 함수의 이름이 일종의 주소에요 함수의 이름은 원래 같으면 안되는데 어 그렇다면

오버로딩은 왜 가능하냐 거기에 더미 파라미터를 붙여가지고 이름을 조금씩  조금씩 바꿉니다. 사실은 같은 이름의

함수는 없어요 그래서 함수의 이름이 호출이 된다는건 이 인스트럭션 셋이라는게 호출이 되는거다. 음 그거를 햇갈리시면

안되는게 어 더하기 기능이라는 부분이 인스턴스마다 따로 생기지는 않는다는 거에요 예수행하는  기능의 셋이라는거

뭐 인스턴스마다 따로 생기거나 함수가 호출할때마다 따로생기는 부분은 뭐다 변수가 사용하는 영역이다 라는거

그니까 변수가 쓰는 영역과 함수의 인스트럭션 셋이차지하고 있는 영역 명령어의 집합이죠 그게 차지하고 있는 영역은 

다른영역이에요 그래서 code영역을 로직이죠 로직만갖고 있는 겁니다. 자 이 애기를 왜 이렇게 열심히 했냐면 가상함수를

설명을 드릴려고 하는거에요 그래서 가상함수의 개념은 다른언어도 비슷하게 적용이 되는데 자바는 모든메서드가 가상함수

에요  가상메서드다라는거죠 그니깐 특별히 애는 가상함수다라고 명시를 하지 않아도 그냥 메서드는 가상함수 방식으로

이루어집니다. 함수의 이름이 주소값을 나타내요 따로 주소를 어디다가 맵핑을 시키는게 아니라 함수를 호출하면 그 함수

이름에 따른 이름과 맵핑되는 주소가 호출이 되는거죠 그 메소드 인스턴스셋이 메서드 영역 우리가 다른말로 코드영역이라고

하는데 거기에 위치를 하게 되고 그주소를 찾아가서 명령어들이 실행이 되는게 함수호출의 방식입니다. 

그때 메서드들을 사용하는 변수들을 스택메모리를 쓰는거죠 따라서  인스턴스가 다르더라도 메소드의 코드는 같아요

같고 다만 인스턴스가 쓰는 변수값이 다른거죠 인스턴스가 생성이 되면 변수는 힙메모리 메서드영역에 인스트럭션셋은

딱 한번만 로드가 된다.라는거 자 여기서 보셨을때 aaa()라는 메서드가 있어요 메서드가 하는일은 시스템객체에 아웃변수에

프린트라인을 호출해서 aaa()함수를 찍는거에요 출력문을 하나 하는거죠 앞에는 다 똑같고 ()안에 문자열이 뭐냐에 따라서

그거를 찍어주는 역할을 애가 할건데 이게 aaa라는 함수데 전체적인 그림에서 보셨을때 이 메인이라는 함수가 있죠 

그냥 같이 만들었습니다. 메인이라는 함수가 a1,a2,args a1부터 args까지 스택메모리에 스택메모리에 메인이라는 함수

가 차지하는 영역이 코드영역이 아니라 이 메인이라는 함수의 지역변수가 차지하는 영역인거죠 당연히 코드영역은 

따로 있는거구요 그러면은 여기에 지역변수가 args아규먼트 a1, a2세개가 있잖아요 그죠 애의 생성된 실제 인스턴스는 

힙메모리위치구요 그리고 a1의 변수로 num변수가 하나있네요 멤버변수로 a1의 num과 a2의 num의 변수들이 따로 

있구요  이 a1과 a2를 이용해서 aaa()라는 메서드를 호출해서 출력을 해라라고 했을때 출력이 실행되기 위해서 호출되는

메서드의 영역은 aaa()메서드영역이라는 거죠 아까 제가 말씀드렸듯이 그부분을 메서드영역이라고 이때 만약에 변수가

필요하다. 라고 하면 스택영역에 또 잡히는거에요 변수가 aaa()라는 메소드의 영역에 스택메모리에 aaa()가 사용하는 지역

변수들이 스택메모리에 잡히는거죠 네 그렇게 되어있습니다. 네 열심히 메소드를 설명드리는이유는 가상메소드를 

설명드릴려고 하는데 이전에는 가상함수 C, C++에서는 가상함수 버쳘펑션이라고 하구요 여기는 자바니깐 가상

메서드라고 이야기를 하고 일단 가상메서드는 뭐냐 실제로 함수이름으로 호출이 되는게 아니라 그 함수이름이 

가르키는 어드레스에 대한 테이블이 따로 있어요 그게 버쳘펑션 테이블이에요 그래서 가상함수 테이블인데 

어 여기는 가상메서드테이블이겠죠 버쳘 메서드테이블을 가지고 있고 그러면 각클래스마다 자기 메서드의 

주소를 갖고 있는데 커스토멍의 칼크프라이스랑 커스토머에 SHOW커스토머인포에대한 메서드주소가

그림처럼 있는거죠 요 메서드영역 요메서드영역 그래서 칼크프라이스라는 메소드가 불리면 이주소가 바인딩이

돼서 칼크프라이스 메서드로 가는거고 쇼커스토머인포라 불리면 이주소가 바인딩이돼서 SHOW커스토머인포

로 가는겁니다. 그리고 VIP커스토머인경우에 가상함수 테이블을 또가지고 있어요 그리고 각메서드마다 갖고 

있는데 쇼커스토머인포같은 경우는 재정의하지 않았죠 그래서 커스토머의 어드레스를 갖고 있는겁니다.

getAgentID는 커스토머쪽에는 없죠 그러니까 VIP커스토머가 혼자 가지고 있는거고 자 칼크프라이스를 보면

칼크프라이스같은경우는 재정의가 돼 있잖아요 애는 어디를 가르키냐면 재정의된 자기 함수를 가르킵니다.

오버라이드된 주소를 가르키는거에요 그러니까 VIP커스토머 인스턴스에 메서드가 호출되게 되면 애는 

어디로 가냐면 가상함수 테이블에 가서 자기의 재정의된 함수가 불린다라는 겁니다. 다시 말씀드리면 

vc라는 변수가 칼크프라이스라는 함수를 호출을 했는데 이 함수가 이 인스턴스 생성된 인스턴스쪽에서 

이함수가 재정의가 됐다라고 하면 재정의된 함수가 호출이 되는거고 재정의가 되지 않았다라고 하면 

원래 함수가 호출이 된다. 재정의가 되지 않았다라고하면 원래 함수가 호출이 되는겁니다. 그래서 

쇼인포는 재정의가 되지 않았으니까 원래함수가 호출이 됐죠 칼크프라이스는 재정의가 됐기 때문에 

재정의가 된 함수가 호출이 되는 겁니다. 이게 가상함수 기법이에요 그렇지 않고 일반적으로 호출한다

라고하면 당연히 커스토머게 불려요 왜냐면 타입이 커스토머니까 그런데 이때 가상함수인경우에는 

가상함수 테이블이 만들어지고 그 클래스마다 그 클래스가 맵핑되는 메서드의 주소를 가지고 있습니다.

그러면서 이 실제 인스턴스에 해당되는 메서드가 호출이 된다. 라는거 그리고 자바의 모든 함수는 

이렇게 만들어진다라는겁니다. 자그러면 우리가 지금까지 쭉 한 내용을 살펴보면요 음 맨처음에 

상속을 했구요 그다음에 형변환 상위클래스로 형이 대입된다. 라는 말씀을 드렸고 그 다음에 

재정의를 했습니다. 상위클래스에 있는 메서드데 하위클래스에서 자기랑 안맞으면 재정의할수 있다.'

그리고 인스턴스의 재정의된 메서드가 불리는 오버라이딩과 가상함수에 대해서 말씀을 드렸죠 

그러면 이것까지 쭉해서 뭐를 이거를 한거를 볼거냐면 다형성이 어떻게 구현되어있는것을 볼거에요

여러다른 클래스타입을 가진 그렇지만 동일하게 코드를 호출해도 다양한 구현결과가 나오는 그런것들을 

다형성 폴리모피즘이라고 하거든요 그래서 여기까지 이해를 하시고 쭉 맥락을 이해를 하셔야 돼요 

쭉 맥락을 이해를 하시고 상속,형변환,그다음에 재정의 가상함수 테이블까지 쭉이야기를 하고나서

그래서 다형성이 이루어진다라는거 왜 이렇게 호출이되느냐라는 의문을 여기까지 이해가 안되시면 

계속갖게 돼요 어 왜 애가 호출이 되지 왜 이게 호출이 되지 그래서 만약에 이해가 안되시면 여러번

다시 반복하더라도 여기까지 이해하시고 다형성이 어떻게 구현이 되는지 다형성의 구현으로 인해서

얼마나 플렉서블한 프로그램을 만들수가 있는지 라는거를 같이 보도록 하겠습니다.  