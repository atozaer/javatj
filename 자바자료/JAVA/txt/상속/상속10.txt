추상클래스 처음 말씀드릴때 추상클래스하고 탬플릿메서드 패턴을 같이 살펴보자고 말씀을 드렸었죠 

템플릿메서드가 뭔지 그 다음에 애가 어떻게 활용될수 있는지 보도록 하겠습니다. 

프레임웍이라는거를 여러분들이 많이 사용해 보신적이 있고 앞으로 실무를 하다 보면 많이 사용을 하실텐데 

프레임웍에 대한 정의는 어떻게 하실수가 있냐면 우리가 일반적으로 라이브러리 가져다 쓰는 여러가지 함수들이

있잖아요 라이브러리하고 프레임웍은 다른거에요 이거를 어떻게 구별을 하시면 되냐면 jdk가 있어요 

jdk는 자바디벨로먼트킷이잖아요 좋은 라이브러리이긴 하지만 프레임웍은 아닙니다. 프레임웍은아니고 

안드로이드 있죠 안드로이드 안드로이드는 프레임웍이에요 jdk에 굉장히 많은 라이브러리들이 있고 

그걸 가져다가 프로그램을 할때 프로그램을 가져다 쓰지만 이전반적인 처음부터 끝까지 프로그램의 플로우

제어권은 이 프로그래머가 가지고 있는거죠 내가 필요한경우의 애에 라이브러를 가져다 쓰지만 대부분의 흐름은

제가 구성을 합니다. 그죠 그런데 안드로이드같은 프레임웍을 우리가 도입한다. 스프링을 가져다 쓴다. 안드로이드

기반의 어떤 프로그램을 짠다라고 했을때 프레임웍을 도입한다는 애기는 뭐냐면 요기 흐름이 다 정해져 있어요 

내가 여기다가 클래스를 넣으면 이클래스가 어떻게 연동이 될것이고 내가 요클래스를 넣으면 이 클래스의 메시지

가 어떻게 날라가서 저 클래스에다가 어떤 영향을 줄것이고 이미 흐름은 다 정해져 있구요 우리가 하는 일들은 

우리가 이걸 플레이스홀이라고 하는데 구멍들을 메꾸는 일들입니다. 이는 틀을 만들었지 안드로이드같은 경우에 

화면을 액티비티 라고 하거든요 화면이 어떻게 돌아간다. 화면이 처음에 효고가 되고 그다음에 뭐들이 있고 그다음에 

그다음에 Close가 되고 디스토리가 된다. 뭐 이런것들은 안드로이드 내부에 정의가 돼 있지만 실제적으로 이화면에서 

위젯이 올라와서 어떤 행동을 취한다. 라는거는 우리가 짜야 되는거잖아요 그니깐은 화면을 액티비티라고 하는데 

화면에 여러가지 생성과정들이나 뭐 개가 소멸되는 과정들이나 그안에서 돌아가는 모든일들은 정해져 있지만 

거기에 들어가는 구체적인 기능 세부적인 기능들 리스트를 올린다던가 버튼을 올린다라든가 그런것들은 프로그래머가

하는 거잖아요 그런 하는게 프로그래머의 역할입니다. 탬플릿 메서드를 애기하기 전에 제가 왜 이애기들을 장황하게 

하냐면 탬플릿메서드는 프레임웍에서 많이 쓰는 패턴이에요 이미 시나리오가 많이 정해져 있어요 어떻게 흘러갈것이다. 

애가 이렇게 값을 넣으면 이값이 어떻게 보여질 것이고 그다음에 이넣은 값이 어떤 클래스에 이영향을 미쳐서 어떤 메시지가 

날라갈것이고 이런것들은 쭉 정해져 있는데 그메시지를 만드는거 클래스를 만드는건 누가 하냐면 프로그래머가 하는거죠 

그래서 프레임웤을 도입을 하게 되면 우리가 프레임웤에 대해서 공부를 해야 되잖아요 그 이유를 뭐냐면 내가 이렇게 

구현을 할때 어떻게 돌아가는줄을 알아야 되는거잖아요 안드로이드를 구현할려면 공부를 해야 되잖아요 그죠 그래서 

프레임웍에서 많이 쓰이는 패턴 중에 하나가  템플릿 메서드 패턴인데 템플릿 메서드 패턴이 하는일은 뭐냐 

템플릿이라는 어떤 틀이잖아요 그래서 틀을 가진 메서드에요 시나리오를 정의를 해놓고 그시나리오에 따라 

이제 흐름이 흘러가는데 그안에 추상메서드들이 있습니다. 그러면 그 추상메서들을 누가 그 메서드 패턴을 가진 

클래스들을 상속받은 클래스쪽에서 구현을 한다라는거죠 네 그래서 추상메서드나 구현된 메서드를 활용해서 

추상코드의 흐름 시나리오를 정의해 둔 메서드라고 합니다. 그래서 이 메서드안에는 실제로 구현된 메서드가 

있을수 있고 추상메서드가 있을수도 있다. 이흐름은 변하면 안돼요 변하면 안돼니까 메서드를 뭐로 선언하냐면 

final날로 선언을 합니다. final날이라는 키워드가 쓰일때가 몇번이 있었죠 상수 선언할때 있었구요 그다음에 지금 

메서드에 선언을 하게 되면 뭐를 할수가 없냐면 상속받은 하위클래스가 재정의를 할수가 없어요 재정의를 못하면 

왜냐면 애는 중요한 시나리오를 가지고 있는 메서드잖아요 제정의를 못하게끔 하기 위해서 final로 선언을 하구요 

클래스에 final이라는 키워드가 들어가면 클래스에 final이 들어가게 되면 상속을 할수가 없습니다. 

상속받지 못하는 클래스에요 왜냐면 이클래스를 상속받아서 이클래스를 재정의한다거나 이클래스의 변수에 

액세스를 해서 값을 바꾸었을때에 문제가 생길수 있기 때문에 상속을 못하게끔 해놓는 그런 클래스들이 있거든요

jdk안에도 많이 있습니다. 그래서 그런 클래스들은 final로 선언을 합니다. final키워드가 변수에 쓰이면 상수고

메서드에 쓰이면 제정의를 못하는 메서드 클래스에 쓰이면 상속이 안되는 클래스 요렇게 세가지를 기억해 

두시면 좋겠습니다. 템플릿메서드 프레임웤 설계 많이 쓰구요 이미 프레임웍에서 만들어진것들을 상속받아서 

구현을 하면서 흐름은 정해져 있다는거죠 추상클래스에서 선언된 메서드에서 템플릿메서드를 활용해서 전체

적인 흐름을 구현을 하고 하위클래스에서는 이젠 구현해야되는 추상메서드들을 구현하도록 합니다. 

간단한 예제를 제가 내놨는데요 여기그림을 보면 Car차가 있어요 차가 Car가 있고 여기에 애가 삐딱하게 

써있는거 보니까 애가 추상클래스라는 것이고 차안에 메서드들을 보면 startCar()하고 turnOff() run()들은 

구현된 메서드이고요 drive()하고 stop()은 추상메서드네요 그래서 차가 두개의 자동차가 있는데 자율주행차

차가 두개의 자동차가 있는데 AICar 자율주행차하고 ManualCar 우리가 손으로 타는 메뉴얼카라고 있습니다. 

그래서 Abstract클래스에 선언을 하셔서 이제 애네들을 구현을 한번 해보고요 run()이라는 메서드가 템플릿

역할을 할겁니다. 저랑 같이 구현을 하면서 저랑 같이 보도록 하죠 

네 package가셔서 ch10넣으시고 클래스를 보시면 abstract키워드가 있어요 이거선택하시면 됩니다. 

public abstract class Car{
     public abstract void drive(); //운전하는거 
     public abstract void stop(); //정지하는거(brack)
      public abstract void wiper(); 

     public void startCar(){
        System.out.println("시동을 켭니다.");
     }
     public void turnOff(){
        System.out.println("시동을 끕니다.");
    }
     public void run(){
        startCar();
        drive();
        wiper();
        stop();
        turnOff();
     }
} 
카에 메서드들이 있는데 자율주행차는 알아서 멈추는 기능이 있죠 시동을 키고 끄는것을 구동합니다. 

우리가 항상 달릴때는 똑같죠 시동을 키고 그다음에 주행을 하다가 멈출일이 있으면 멈추고 나중에는 

시동을 끄고 이렇게 주행을 할겁니다. run함수안에서 필요한메서드들을 부르는 겁니다. 애가 추상메서드건

구현된 메서드건 상관없이 출발을 하고 운전을 하고 멈추고 시동을 끕니다. 요렇게 구현을 했습니다. 

요시나리오는 말씀을 드렸지만 변하면 안돼요 run()왜냐면 애는 요순서대로 돼야죠 드라이브는 스타카하기전에 

드라이브를 먼저할순없죠 그렇기 때문에 애는 변하면 안돼니깐 final로 선언을 합니다. 

하위클래스에서 제정의를 못한다. 그리고 나서 AICar를 한번 만들어 볼까요 

public class AICar extends Car{

@Override
public void drive(){
     System.out.println("자율주행을 합니다.");
     System.out.println("자동차가 스스로 방향을 바꿉니다.");
}
@Override
public void stop(){
     System.out.println("장애물앞에서 스스로 멈춥니다.");
}
}

하면 니가 구현해야 되는 메서드가 있어 drive() stop()두개가 나오죠 

public class ManualCar extends Car{

     @Override
     public void drive(){
           System.out.println("사람이 운전합니다.");
           System.out.println("사람이 핸들을 조작합니다.");
     }
     @Override
     public void stop(){
           System.out.println("장애물 앞에서 브레이크를 밟아서 정지합니다.");
     }
     @Override
     public void wiper(){
          
     }
}

실행을 해볼까요 실행을 해보면 

public class CarTest{
     public static void main(String[] args){
          Car aiCar = new AiCar();
          aiCar.run();
          System.out.println("==================");
          Car mCar = new ManualCar();
          mCar.run();
    }
}
run하면 애가하는일은 

시동을 켭니다. 
자율주행을 합니다. 
자동차가 스스로 방향을 바꿉니다. 
장애물 앞에서 스스로 멈춥니다. 
시동을 끕니다. 
시동을 켭니다.
사람이 운전합니다. 
사람이 핸들을 조작합니다. 
장애물 앞에서 브레이크를 밟아서 정지합니다. 
시동을 끕니다. 

요런시나리오를 가진 클래스들이 있고 이런 시나리오가 정해져 있으면 

이거는 우리가 변경을 시킬수가 없습니다. 변경을 시킬수는 없고 

그 대신에는 아니고 필요에 의해서 쓰는거니까 요기에 필요한 메서들은 각각의 클래스에서 정의를 한다. 

보시면 되구요 여기에다가 내가 어떤 기능을 하나 추가를 하고 싶다. 라고 하면 어떻게 하시면 되겠어요 

Car클래스에가서 public abstract void wiper(); 비가오면 와이퍼가 움직이잖아요 요렇게 줬습니다. 

run()메서드내에서 wiper(); 애네들에 오류가 생기죠  왜 오류가 생기냐면 기존에는 추상메서드가 없었는데 

추상메서드가 추가된겁니다. 너네들은 애네들을 구현을 해야되 라는거죠 add unimplmented를 추가합니다. 

빨간줄에서 구현을 하면됩니다. 그리고 저장을 하시면 되구요 또 어떤 메서드를 활용을 할수 있는거냐면 

추상클래스에다가 washCar(); 근데 애가 추상클래스면 반드시 다음클래스에다가 무조건 구현을 해야되는거죠 

그죠 그런데 

public void washCar(){ }

요 메서드는 추상메서드가 아니라 구현된 메서드에요 구현된 메서드데 뭐가 없는거다 구현내용이 없는겁니다. 

중괄호를 열고닫으면 구현부가 있는데 구현내용이 없는거에요 statement스테이트먼트 문장이 없는거에요 

구현이 안된게 아니에요 그래서 애는 추상메서드가 아니기 때문에 저장을 해보시면 오류가 나질않아요 

그러면 애는 뭐에다 쓰느냐면 필요한 경우에 재정의를 하는거에요 만약에 이걸 아무것도 안하면 실행을 하잖아요 

요것만 요렇게 나와요 

시동을 켭니다. 
자율주행을 합니다. 
자동차가 스스로 방향을 바꿉니다. 
장애물 앞에서 스스로 멈춥니다. 
시동을 끕니다. 
시동을 켭니다.
사람이 운전합니다. 
사람이 핸들을 조작합니다. 
장애물 앞에서 브레이크를 밟아서 정지합니다. 
시동을 끕니다. 

@Override
public void washCar(){
      System.out.println("자동 세차를 합니다.");
}

 public void run(){
        startCar();
        drive();
        wiper();
        stop();
        turnOff();
        washCar();
     }


실행을 하면 

시동을 켭니다. 
자율주행을 합니다. 
자동차가 스스로 방향을 바꿉니다. 
장애물 앞에서 스스로 멈춥니다. 
시동을 끕니다. 
자동세차를 합니다. 
==============================
시동을 켭니다.
사람이 운전합니다. 
사람이 핸들을 조작합니다. 
장애물 앞에서 브레이크를 밟아서 정지합니다. 
시동을 끕니다. 

인공지능차에는 자동세차가 출력이 되고 와시카가 washCar가 자동세차를 하고 

수동차에는 자동세차가 출력이 되지 않습니다. washCar(){ }가 구현을 하고 재정의를 안한거죠 

없잖아요 washCar가 없잖아요 이런메서드를 우리가 뭐라고 예기하냐면 훅메서드라고 이야기를 해요 

훅들어오는건 아니구요 훅메서드라고해서 필요한 경우에 상위클래스에서 요렇게 써놓은 메서드를 

제정의해서 쓸수도 있습니다. 탬플릿메서드에대해서 정리를 해드리면 시나리오를 정의하는 메서드라고 

했고 프레임웍에서 많이 쓴다고 말씀을 드렸구요 추상클래스에서어떤 메서드를 구현하고 어떤 메서드를 

구현하지 않을 것이냐 라는걸 봤을때 공통으로 사용될 메서드를 구현하시면 되고 그러지 않은 메서드를 

추상메서드를 남겨두시고 공통으로 구현을 한다라고 정의한 메서드도 하위클래스에서 재정의를 할수 있다. 

그렇게 구현한 메서드중에 절대 재정의를 하면 안되는 메서드들은 뭘로 선언한다. final날로 선언한다. 

라고 말씀을 드렸습니다. final예약어 상수에 쓰이고 메서드에 쓰이고 클래스에 쓰일때는 상속할수 없다. 

extends 확장할수 없다. 그래서 String이라는 클래스는 extends할수 없어요 final로 선언되 있구요 이거는 

여러분이 눈으로 좀 static을 배우셨고 코드만 눈으로 보겠습니다. 퍼블릭스태틱파이널이라고 선언을 해서 

정수값들이나 필요한 상수값들 스트링들을 한곳에 모아놓으면 나중에 필요한경우에 나중에 필요한 경우에 

new하지 않고 Difine.점해서 가져다 쓸수가 있어요 프로그램안에서 공통으로 쓰여야하는 값들을 요렇게 

사용할수 있다. 요렇게 하시면 될것 같습니다. 요렇게 쓰시는 경우가 있고 인뉴머레이션이라는 방법도 있고 

두가지가 있는데 요렇게 쓸수도 있고 인뉴머레이션이라는 방법을 이용해서 쓸수도 있습니다. 추상클래스와 탬플릿메서드패턴까지 알아봤습니다. 

public class Define {

     public static final int MIN = 1;
     public static final int MAX = 999999;
     public static final double PI = 3.14;
     public static final String GREETING = "Good Morning!";
     public static final int MATH_CODE = 1001;
     public static final int CHEMISTRY_CODE = 1002;
}

UsingDefine.java

public class UsingDefine{

       public static void main(String[] args){
                 System.out.println(Define.MIN);
                 System.out.println(Define.MAX);
                 System.out.println(Define.MATH_CODE);
                 System.out.println(Define.MATH_CODE);
                 System.out.println(Define.CHEMISTRY_CODE);
                 System.out.println("원주율은"+Define.PI+"입니다.");
       }
}







 

 