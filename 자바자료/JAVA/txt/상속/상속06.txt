자 다형성에 대해서 말씀을 드릴건데요

일단 다형성 폴리모피즘이라고 하고요 하나의 코드가 여러자료형으로 구현되어 실행되는것이다. 원래 자료형 하나와

메소드가 호출이 된다거나 변수가 대입되거나 배열이 만들어진다거나 이렇게 되야 되는데 여러 자료형이 같이 구현될

수 있다는거 같은 코드에서 여러다른 실행결과가 나오는거 분명히 이코드가 하나데 임플리먼테이션의 결과 구현의 결과

실행을 해보면 다른결과가 나온다는거죠 정보은닉 상속과 더불어 객체지향의 특징중 가장큰특징중의 하나라고 볼수 

있구요 음 잘활용하면 유현하고 확장성있고 유지보수가 편리한 프로그램을 만들수 있다. 객체지향처음할때 객체지향의

장점이라고 말씀을 드렸고 이게 인제 잘활용하면 그렇게 할수 있습니다. 잘못하면 또 힘든면이 생기지만 그래서 분명히

유용한 프로그램이 될수도 있는데 어떻게 구현되는지를 간단한 예제를 저랑 같이 만들어보면서 애기하고 음 한번 생각

해보도록 할게요 자이제 우리가 패키지가 kr.or.kh06을 생성합니다. 클래스를 생성합니다.  AnimalTest클래스에 main함수

를 작성합니다. 요 위에 Animal 이라는 클래스를 하나 만들었어요 동물이죠 왠지 제너럴한 클래스니까 상속이 될것 같죠

class Animal{

	public void move(){
	     System.out.println("동물이 움직입니다.");
	}
}
class Human extends Animal{

@Override
public void move(){
System.out.println("사람이 두발로 걷습니다.");
}

public void readBook(){
System.out.println("사람이 책을 읽습니다.");
}
}
class Tiger extends Animal{
@Override
public void move(){
 System.out.println("호랑이가 네발로 뜁니다.");
}
public void hunting(){
System.out.println("호랑이가 사냥을 합니다.");
}
}
class Eagle extends Animal{
@Override
public void move(){
   System.out.println("독수리가 하늘을 날아 다닙니다.");
}
public void flying(){
 System.out.println("독수리가 양날개를 쭉 펴고 날아다닙니다.");
}
}
move라는 메서드를 만들었고 여기서 하는일은 간단합니다.  휴먼 사람은 동물이니까 상속을 받습니다.

그런데 사람이 움직인다라는거에 동물이움직입니다 라고 쓰는 거는 좀 그렇죠 오버라이딩을 합니다.

바로쓰셔도 됩니다. 저희는 이클립스에 소스에 오버라이딩을 하겠습니다. move를 오버라이딩을 하겠습니다.

사람이잖아요 사람이 할수있는 메서드를 하나 추가를 했어요  다른 동물들하고는 차별하된 기능이죠 

휴먼말고 이번에 타이거한번 해볼까요  호랑이가  네발로 뜁니다. 호랑이만이 가지고 있는 헌팅(사냥)을

잘하니까 자 그리고 이번에는 독수리 독수가 하늘을 날아다닙니다. 그리고 독수리가 플라잉 독수리가 

양날개를  쭉 펴고  날아다닙니다. 그 밑에 휴먼 타이거 이글 이렇게 세개의 클래스가 상속을 받았다는 

거죠 그렇게 했을때 이제 애니멀 테스트라는 클래스는 상속받은 클래스를 돌려보기 위한 메서드만 

가지고 있는 클래스입니다. 그래서 애니멀을 만드는데  Animal로 선언하고 Animal hAnimal = new Human();

을 만들어요 마찬가지로 이글과  타이거도  이렇게 만들어 보겠습니다. 

Animal tAnimal = new Tiger(); Animal eAnimal = new Eagle(); 요렇게 만들었죠 그죠 자 요렇게 만들고 나서 

move를 할건데 요기 밑에다 메서드하나 만들까요 

AnimalTest test = new AnimalTest();
test.moveAnimal(hAnimal);
test.moveAnimal(tAnimal);
test.moveAnimal(eAnimal);

public void moveAnimal(Animal animal){
	animal.move();
}

왜냐면 사람 타이거 독수리가 전부다 에니멀 타입이죠 그렇기 때문에 뭘로 형변환이돼냐 상위클래스인 에니멀로 형변환이

된다라는거죠 그리고 무브라고 했어요 그리고 런 해보시면 자 출력결과를 보겠습니다. 사람이 두발로 걷습니다.  

호랑이가 네발로 뜁니다. 독수리가 하늘을 날아다닙니다. 자 코드는 한줄인데 어떤 데이터형이 들어갔느냐에 따라

어떤 인스턴스형이 들어갔느냐에 따라 이 무브의 임플리먼테이션이 달라지죠 이게 바로 다형성입니다. 다형성 

이부분이 다형성인거죠 이 다형성이 구현되는 전반적인 원리를 보시면 상속을 했구요 상속이 된이후에 물론 나중에

인터페이스로 다형성을 구현합니다. 그런데 상속이 됐고 그 상속에서 메서드 오버라이딩을 했고 형변환이 일어났죠

그래서 하위클래스로 상속을 하게 되면 상속을 하게 되면 하위클래스들을 상위클래스하나의 타입으로 모두 핸들링

할수 있어요 이게 어떻게 보면 굉장히 좋은 면도 있는데 클래스간의 결합도가 굉장히 타이트해진다고 이야기를 

합니다. 그래서 상위클래스를 바꾸면 하위클래스에 영향을 미칠수가 있거든요 그래서 상속을 설계할때는 

꼭 필요한경우 굉장히 신중하게 설계를 하셔야 되는데 어 여기서 보셨을때 보시면 여러클래스타입을 하나의 에니멀 

타입으로 핸들링을 하면서 애가 결국 무브라고 했을때 각각 인스턴스의 메서드가 호출이 된다고 했죠 그죠 가상함수

가상메서드 방식에 의해서 그래서 무브의 메서드가 호출이 됩니다. 그런데 뭐는 안돼냐 계속 애기를 드리지만 

휴먼이 가지고 있는 리드북이나 타이거가 가지고 있는 헌팅은 호출할수가 없어요 이 타입에서는 그러면 어떻게 

해야 되느냐 애를 다시 다운캐스팅을 해야 됩니다. 다운캐스팅을 해야되구요 그다음에 나중에 추상클래스에서도 

말씀을 드리겠지만  공통적으로 쓰일수 있는 메서드가 있다. 라고 하면 상위클래스에 그냥 선언을 하시면 돼요 

상위클래스에 선언된 공통의 메서드는 모두 하위클래스에서 사용을 할수가 있습니다. 이게 또 코드재사용의 

방법인거죠 그죠 그리고 추가적으로 다른 동물이 추가된다 그러면 extends익스텐즈해서 사용하시면 됩니다.

그래서 다형성이라는 부분은 다른클래스들이 한꺼번에 마치 동일한 타입인것처럼 쓰이지만 실제적인 임플리

먼테이션은 다르게 각각 나타날수 있다. 우리 배열할때  어레이리스트 배웠잖아요 지금 이세동물들을 어레이

배열에 다넣고 싶어요 그러면 어레이리스트타입을 에니멀이라고 하면 되겠죠 

ArrayList<Animal> animalList = new ArrayList<Animal>();
animalList.add(hAnimal);
animalList.add(tAnimal);
animalList.add(eAnimal);

이렇게 넣고요 우리가 인네스트포했었잖아요 

for(Animal animal : animalList){
  animal.move();
}

라고 호출하면 위에 출력을 주석으로 처리할까요 

run해보시면 출력이 나오죠 요것도 한줄이지만 어떤 애니멀인가에 따라서 다른 임플리먼테이션이 나온다. 

이게 다형성이에요 굉장히 확장성있는 프로그램을 만들수 있다는것도 여러분은 느낄수 있을 겁니다.

네 그러면 수업교안을 좀 보시면 방금전에 했던 예제를 보여드렸구요 그러면 내가 플라잉을 내가 다시 

쓰고 싶다 그러면 어떻게 해야 되느냐 그때는 다운케스팅을 하셔야 돼요 다운캐스팅은 다음에 다시 

말씀을 드리도록 하겠습니다. 어 다형성을 사용하는 이유가 뭐냐 지금생각했을때 제가 말씀을 드렸지만 

다른동물을 추가를 한다라든가 확장성있는 프로그램을 만들수 있다고 말씀을 드렸죠 만약에 다형성을 

쓰지않고 상속을 쓰지 않고 그냥 고객 여러고객을 하나의 클래스에다 다 때려 놓고 그 다음에 각각의 

메서드가 그 고객에 등급에 맞는 기능을 제공을 한다라고하면 등급에 따라서 if~else 구문이 메서드마다

들어가야 돼요 뭐 가격에 대한 부분도 있을수 있고 그다음에 연말선물에 대한 부분도 있을수 있고 

그다음에 이분한테 프로모션을 어떻게 할건지 그런부분도 있을수 있고 그다음에 쿠폰을 어떻게 줄건지

뭐 이런것들이 다 다를수 있잖아요 구현이 그런데 그 구현들이 다 하나의 클래스안에 if문으로 계속 

증가돼요 그리고 만약에 그레이드 등급이 또 추가됐다 VIP GOLD SILVER데 블랙리스트가 있다. 

그러면 블랙 그분들은 접속을 차단한다거나 서비스를 안해 줄거 아니에요 그러면 그런거에 대한 

계속 if~else 가 증가하거든요 어 우리가 리팩토링을 한다라고 이야기를 하는데 아 한번 만든 코드가 

조금 개선할부분이 많다 라고 하면 다 뜯어고치는 겁니다. 결국은 리팩토링인데 음 너무 if~else 구문이

많은 메서들이 하나의 클래스에 여러개 있다라고 하면 음 그것은 클래스를 분리해 볼 필요가 있어요 

그래서 대부분 하나의 어떤 조건에 의해서 갈리는 나뉘는 로직인경우에는 if~else문들을 클래스화하시는게

맞습니다. 그래서 그렇게 쓰지 않으면 if~else if구문이 많아진다. 상위클래스에서는 공통적인 부분을 

제공하고 하위클래스에서 각각맞는 오버라이딩(재정의)한다거나 추가해서 하시면 됩니다. 

여러클래스를 하나의 상위클래스로 핸들링할수 있다는 장점이 있죠 음 우리 지금까지 인제 

그 멤버쉽 프로그램 만들었잖아요 그런데 추가적인 요구사항이 나왔어요 요기 보시면 요거까지 해서 좀더 

완성된 멤버쉽프로그램을 만들어 보도록 하겠습니다. 예전에 일반고객과 VIP고객이 있었는데 자 고객의 

타입이 늘었습니다. 자 일반고객과 VIP고객의 중간에 멤버쉽을 하나 만들었으면 좋겠다. 그래서 

VIP보다는 적게 구매하지만 그래도 혜택을 좀 줬으면 좋겠다 단골인거죠 그래서 골드등급에 고객을 

만들어보겠습니다. 어 이런 요청이 들어왔죠 제품을 살때 10프로를 똑깥이 할인을 해주고 VIP랑 똑같죠

그대신 보너스포인트는 2프로만 적립을 해주고 그리고 이분은 담당하는 전담상담원은 없습니다. 그러면 

이거를 그냥 만든다라고  하면 커스토머에다가 넣는다거나 하면 문제점이 있다고 했죠 이미 우리는 

커스토머가 있고 커스토머하위에 VIP가 있죠 그러면 음 우리가 상속을 할때 깊이를 너무 길게가는것도

좋지는 않습니다. 그래서 골드를 VIP에 상속받는다 그게 아니라요 그래서 커스토머에서 상속을 받아서

사용을 하시면 될것 같습니다. 같이 구현을 해볼게요 그전에 4강에서 한것을 그대로 복사해 오시면 되구요

저희는 처음부터 코딩을 하겠습니다. 여기 커스토머있고 VIP에 칼크프라이스까지 정의가 돼 있잖아요 

그럼 추가해서 클래스 GoldCustomer라고 만드시고 슈퍼클래스 모든자바의 최상위클래스는 오브젝트

클래스입니다. kr.or.kh06장에 있는 커스토머를 상속을 받는다 이렇게 해서 피니쉬하시면 만들어집니다.

다른 프레임웍이나 클래스를 상속을 받아도 요런 경우가 생겨요 뭐를 해라 애가 처음에 하라는게 뭐냐면

아까 우리가 디폴트생성자가 없잖아요 그렇기 때문에 생성자를 개발자가 직접 호출을 해야된다라는거고

public class GoldCustomer extends Customer{
	public GoldCustomer(int customerID, String customerName){
	super(customerID, customerName);
	}
}
추가적으로 여기에 필요한 변수를 생각을 해보면 할인률만 적용이 되니까 세일즈레이쇼 하나만 작성을 하겠습니다.

double salesRatio; 세일즈레이쇼가 얼마냐 10프로라고했죠 salesRatio = 0.1; 보너스비율에 대한 bonusRatio = 0.02;

직접 쓰는것보단 오버라이드의 이클립스기능을 쓰는게 좋습니다. 컴파일 오류도 막아주고 칼크프라이스를 오버라이드

해줍니다. 

@Override
public int calcPrice(int price){
	bonusPoint += price * bonusRatio;
	return price - (int)(price * salesRatio);
}

CustomerTest는 기존의 소스는 지우구요 ArrayList<Customer> customerList =new ArrayList<Customer>();

자고객들을 생성해 보겠습니다. 고객Customer커스토머2명 골드커스토머2명 VIP커스토머한명 총5명을 어레이

리스트에 넣고 한번 핸들링을 해볼게요 

Customer customerT = new Customer(10010,"Tomas");
Customer customerJ = new Customer(10020,"James");
Customer customerE = new GoldCustomer(10030,"Edward");
Customer customerP = new GoldCustomer(10040,"Percy");
Customer customerK = new VIPCustomer(10050,"Kim");

자그럼 고객들을 어레이리스트에 다넣을게요 

customerList.add(customerT);
customerList.add(customerJ);
customerList.add(customerE);
customerList.add(customerP);
customerList.add(customerK);

어레이리스트는 순서가 있기 때문에 나중에 넣은 순서대로 출력이 돼요 지금 세종류의 고객이 있지만 모두 상위클래스로 핸들링을 한다.

그리고 커스토머 리스트에 커스토머 타입의 배열에 다 넣습니다. 고객정보 출력 한번 해볼까요 이네스트포 향상된 포문으로 해서

for(Customer customer : customerList){
System.out.println(customer.showCustomerInfo());
}

쇼커스토머인포는 상위클래스에 있는 메소드니까  실행해 보면 오류가났네요 

GoldCustomer에 CustomerGrade = "GOLD";

다시실행을 해보시면 실버2명 골드2명 VIP한명 다섯명이 나왔습니다.

자 그럼 뭐를 해보고 싶냐면이들이 얼마를 지불했는지를 알아보고 싶습니다.


똑같은 만원짜리를 샀다라고 해보죠 

int price = 10000;

for(Customer customer : customerList){
    int cost = customer.calcPrice(price);
}

요 칼크프라이스안에서 가격하고 보너스포인트가 적립이 되잖아요 그러면은 고걸한번 출력을 같이 해볼게요 

System.out.println(Customer.getCustomerName()+"님이"+ cost+"원 지불하셨습니다");
System.out.println(Customer.getCustomerName()+"님의 보너스포인트는"+ customer.bonusPoint + "입니다.");

다형성이죠 지금보시면 아시겠지만 여기게 칼크플라이스 가격이 어떤종류의 고객이 호출되느냐에 따라서 다르게 호출될수가 있습니다.

Run해볼까요 결과가 잘나옵니다.