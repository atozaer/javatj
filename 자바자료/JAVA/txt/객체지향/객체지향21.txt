자 이제 객체배열을 어떻게 사용하느냐를 한번 살펴보도록 하겠습니다.

객체들을 배열로 선언할때도 마찬가지로 그 몇개 선언을 해요 선언을 하는데 음 여기보시면 아시겠지만 여기 다섯개를 

선언을 한거거든요 다섯개를 선언을 하면 0부터 4까지 잡히는데 우리가 테스트할게 Book이다. 라고 하면 이제 북 다섯

개가 잡히는게 아니에요 뭐 퍼얼슨이다. 스튜어던트다 라고 하면 스튜어던트 10개 잡으면 10명의 학생이 쭉 잡히는게 

아니라 10명의 학생의 참조변수 주소 어드레스가 들어갈 방만 잡혀요 이게 32비트인경우에는 4바이트구요 64비트인경우

8바이트겠죠 객체가 이렇게 쫙 잡히는게 아니라 그럼 객체는 어떻게 하느냐 객체는 일일이 만드셔야 돼요 여기 뒤에 

예제를 보면 객체를 하나하나 만들어서 집어넙니다. 어 Book이 5개다 라고 하면 나중에 객체를 하나하나 만들어서 

지금 Book[] library = new Book[5]; 지금 요 코드는 아니죠 지금 요코드는 가리키는것만 생성하는거고 아래에 보면

library[0] = new Book("태백산맥1","조정래"); 하나하나 만들어서 집어넙니다. 그래서 다시 말씀드리면 객체에 대한 

배열을 우리가 이젠 퍼얼슨 5개 이렇게 잡으면 퍼얼슨 5개가 잡히는걸로 이렇게 오해를 하는데 그게 아니라 퍼얼슨

5개짜리 주소를 저장할 방만 요렇게 잡힌다. 요거는 저랑 Book클레스를 테스트를 해볼거에요 북이라는 클레스를 

만들고요 그다음에 이책이 저장되게끔 이제 배열을 만들고 그다음에 어떻게 저장이 됐는지 한번 살펴보도록 하겠습니다.

이클립스한번 여시고 이클립스여시고 한번해보죠 자 패키지 가셔서 kr.or.kh21 생성하시고 일단 배열에 넣을 객체로

Book을 만들겠습니다. 어 책에도 여러가지 속성이 있겠죠 이름도 있고 저자도 있고 뭐 출간일도 있고 여러가지가 있을

텐데 간단하게 두개만 할게요 private String title; 책이름하고요 private String author; 저자가 누구신지 음 get/set로 

만들까요 만들고요 public Book(){ }디폴트컨스터럭터도 만들어놓고요 public Book(String title,String author){
   	this.title = title;
	this.author = author;
}
자 이제 책이라는 객체를 만들었구요 그다음에 맨밑에 저장하고 책이름만 출력하게끔 하겠습니다. 

public void showInfo(){
	System.out.println(title+","+author);
}
요렇게 만들었구요 책을 가지고 있는 배열을 만들어보지요 BookTest라는 클레스에 메인넣으시고 피니시

자 처음에 Book[] library = new Book[5]; 이렇게 했다고 해서 책이 5개 잡히는게 아니라고 말씀을 드렸죠

기본자료형하고 가장 큰차이는 기본자료형은 몇바이트짜리라는게 정해져 있고 그바이트만큼 딱 잡히면 되는데

객체는 그렇지는 않잖아요 물론 거기에 인트나 뭐 이런것들이 속성이 있는거를 대충계산을 할수 있지만 

문자열같은 경우도 얼마나 잡아야  할줄은 모르죠 그래서 이런경우에는 이제 어떻게 들어가느냐 이 라이브러리를 

한번찍어볼까요 for(int i=0;i<library.length;i++){

System.out.println(library[i]);

}

여기에 뭐가 들어가 있나 보시면 null이들어가 있죠 그래서 제가 new하면 초기화가 됩니다 정수는 0 그다음에 더블은 

0.0 그다음에 객체는 null로 초기화가 된다. 이렇게 말씀을 드렸구요 여기다 우리가 객체를 직접 new를 해서 넣는거에요

그림에서 보셨지만 여기에 null null null이렇게 들어가는데 애네들은 32비트라고 그러면 32비트컴파일이 됐다라고 하면

애는 4바이트에요 4바이트 4바이트가 되는거고 거기다 이제 책을 집어넣어 보겠습니다.  for명령어는 주석처리를 하고요

library[0] = new Book("태백산맥1","조정래"); 해서 넣으시면 돼요 코딩하기 편하게 시리즈를 

library[1] = new Book("태백산맥2","조정래"); library[2] = new Book("태백산맥3","조정래"); library[3] = new Book("태백산맥4","조정래");

library[4] = new Book("태백산맥5","조정래"); 잘드어갔나 확인을 좀 해봅시다. for해서 책이죠 

for(Book book : library){   
     System.out.println(book);
     book.showInfo();
}
실행을 해서 결과를 보시면 kr.or.kh21.Book@fffff 태백산맥1, 조정래 출력이 잘나옵니다. 그러면 요기에 어드레스가 따로따로

잡혔고 그다음에 요렇게 객체가 만들어진거를 보실수가 있습니다. 객체어레이쓰실때는 여러분이 주의하셔야 되는게 그냥 

new한다고 만들어지는게 아니라 Book객체를 만들어서 넣어야된다. 라는거 생각하시면 되구요 객체배열을 한번 복사해 

볼게요 복사할때 우리가 많이 쓰는게 System.arrayCopy()라는걸 많이쓰는데 System.으로 갖다 쓴거보니까 스태틱메소드

인거 같죠 스태틱메서드고 어 src소스 그다음에 소스포지션 소스가 되는 어레이배열  어디서부터 데스테이션 어디로 그다음

어디부터 배열이 두개가 있잖아요 요쪽으로 카피를 한다. 한쪽이 src소스가 되구요 이게 dest가 되고 애는 0부터 몇개를 

카피를 할거다 요기를 랭스입니다. dest의 어디위치부터 dest의 어디위치부터 0부터 당연히 시작하죠 여기서부터 복사할

수가 있겠죠 1번인덱스부터 복사할수도 있겠죠  원본에서 대상으로 순서대로 이렇게 복사가 되도록 이렇게 하는 메소드

데요 음 int져로 하면 인티져나 플로트로 하면 갯수만큼 잘 복사가 돼요 복사가되고 스타트포지션하고 데스트페이지 포지션

이 잘 매칭이 되서 복사가 되는데 음 갯수가 원본배열보다 크게 원본을 10개를 복사할건데 사본이 10개가 안된다 그럴때

오류가 납니다. 그렇지 않은 경우는 복사가 되는데 우리가 객체를 한번 복사를 해볼까요 객체에서는 어떻게 복사가 되는지

한번 같이 살펴보도록 하겠습니다. 자 오브젝트카피가 어떻게 되는지 기존Book소스를 가지고 할게요 클레스를 작성해서요

ObjectCopyTest 클레스를 작성하고 메인넣으시고 피니시하시면 되겠습니다. 아까 만들었던 애있죠 Book클레스를 카피해

오겠습니다. Object클레스로 복사를 해오구요 주석문은 안쓸거니까 빼겠습니다. 복사할 배열을 한번 만들게요 

Book[] copyLibrary = new Book[5]; 요렇게 만들었다.그럼은  원본배열에 있는거를 사본배열에다가 복사를 할거에요 

System.arrayCopy(library,0,copyLibrary,0,5);라이브러리에서 0부터 데스트데이션에다가대상배열에다가,0부터, 

5개를  복사해라 라는 애기죠 복사가 된 원래의 오리지널내용하고  라이브러리의 내용하고 

System.out.println("==library==");

for(Book book : library){
	System.out.println(book);
	book.showInfo();
}
System.out.println("== copy library ==");
for(Book book : copyLibrary){
	System.out.println(book);
	book.showInfo();
}
위에 있는것은 원래배열 그다음에 아래는 카피된배열 출력을 해보겠습니다. 출력을 해보시면 라이브러리내용 패키지하고 

다 들어가 있구요 카피된 내용도 보면 위에랑 똑같애요 똑같죠 똑같습니다. 근데 여기서 주의해서 보면 이주소도 똑같애요

주소도 똑같구요 그래서 이런일이 발생을 하는거죠 어 배열이 두개가 있는데 그중에 library라이브러리에 제로번째에다가

library[0].setAuthor("박완서") 책을 바꿨어요  library[0].setTitle("나목"); 바꾸고 나서 출력을 한번 해볼까요 출력을 해보면 

객체복사소스를 두개다 주석처리하고 run을 하면 바겼죠 나목 박완서 바꼈잖아요 그러면 애만 바꼈나 

카피된 라이브러리도 놓고 같이 바꼈죠 그죠 같이 바뀐것을 확인하실수가 있습니다. 이게 왜 같이 바꼈냐 복사를 했는데

같이 바뀐 이유를 인제 살펴보시면 음 제가 그림을 한번 그리면서 말씀을 드릴게요 첫번째가 라이브러리고 애가 카피 

라이브러리에요 가운데에 책 다섯권이 있어요 라이브러리가 방이 5개였죠 copy라이브러리도 방이 5개데 아까 코드

보시면 아시겠지만 원본이 사본에게 복사해준거는 주소만 복사해줬어요 원본도 Book을 가르키고 사본도 Book을 

가르키죠 이거를 우리가 샬로드카피 앝은복사라고 하거든요 결국 이배열두개가 복사는 됐지만 같은 애들을 갖고

있는 거죠 Book의 값이 바뀌게 되면 원래배열하고 나는 원래배열만 바꾸고 싶다 아니면 1번지Book의 값을 

카피된 배열에서 바꿨다. 라고 해서 두개의 배열에 영향을 미치게 되는거죠 나는 이걸 원하지 않고 정말 따로 

객체를 갖고 싶다 라고하면 어떻게 하셔야 되냐면요 그다음에 제가인제 Book을 이걸 깊은복사라고 이야기를 하는데

처음에 이렇게 라이브러리가 있잖아요 library[1]~이렇게 만들었고  책을 아래처럼 이렇게 따로 만드셔야 돼요 

copyLibrary[0] = new Book(); new 하셔서 인스턴스를 그러면 그림이 이게어떻게 되냐면  원본배열이 있죠 

가운데 책이 있었잖아요 애가 태백산맥1 2 3 4 5이렇게 돼 있었죠 그리고 이게 라이브러리라는 애기죠 

원래배열 책을 가르쳤어요 그리고 나서 copyLibrary를 하나더 만들었어요 12345개고 그리고 나서 new Book();

했죠 대상배열에서 Book객체를 가르쳤습니다. 원본배열의 주소값을 대상배열에다가 복사를 해주는거에요 

대백산맥1,2,3,4,5그럼 두개의 값은 같지만 다른객체가 되고 원본배열의 주소값을 변경한다고 해서 대상배열의

값이 변경되지는 않는다.그렇게 할수 있습니다. 이거를 우리는 깊은복사라고 한다. 필요에 따라서 쓰시는 거에요

두개의 배열이 같은 객체를 가르켜야 되는 상황이다 라고 하면 앝은복사를 쓰시면되는 거구요 두개의 배열이 

다른 객체를 사용해야 된다 라고하면 여기보시는것처럼 객체를 일일이 다 만드시고 객체를 만드신 다음에 

이 객체에다가 원래 라이브러리 개의 타이틀과 어서를 복사를 해서 만들어주시면 두개는 서로다른 원본배열에서

라이브러리를 설명을 드렸고 원본테이블의 값을 가르치고 있으면 그렇게 할수도 있습니다. 그래서 우리가 이젠

그래서 두개의 값은 같지만 서로다른객체가 되고 원본 라이브러리를 변경한다고 해서 대상라이브러리에 

영향을 미치지 않는다.거죠 그렇게 할수 있습니다.그래서 이거는 우리가 깊은복사라고 한다. 필요에 따라서

쓰시면 되는거에요 두개의 배열이 같은객체 두개는 전혀다른객체를 가르키게 된다. 요거는 저랑또 책은 

안만들었잖아요 디폴트컨스트럭터는 이메서드는 필요없죠 네 일단 책을 쭉 만들고요 System.arrayCopy(...){ }

사실우리는 주소를 많이 복사할 필요가 없죠 System.arrayCopy(); 네 사실은 우리가 직접 일리먼트하나하나

돌면서 그 값을 집어넣어주셔야 돼죠 for(int i=0;i<library.length;i++){
	copyLibrary[i].setAuthor(library[i].getAuthor());
	copyLibrary[i].setTitle(library[i].getTitle());
}
그 값을 죽 복사를 해주는거죠  그러면 인제 인스턴스가 다 따로 만들어서 값만 복사돼있었구 라이브러리에 제로번째거를 

첫번째 엘리먼트의 값을 바꿨을때 두개가 어떻게변하는지 run을 해보시면 주소도 다르죠 주소도 다른거 확인하실수가 

있고 원본배열이 바뀌어도 사본배열은 바뀌질않습니다. 음 객체복사 쓰실때 가금 혼돈하시는 경우가 있어요 그래서 

주소까지 찍으면서 같이 말씀을 드렸구요 이거를 필요에 의해서 같은 객체를 가르킬  필요가 있다 그배열이  굳이 

인스턴스를 만들어서 하시면 오히려 오버헤드가 돼죠 그렇지만 그냥 그대로 인스턴스값을 복사해서 새로만들겠다.

라고하면 일일히 객체를 만드시고 복사하시면 된다.하시면 되겠습니다. 객체배열까지 살펴봤습니다.


