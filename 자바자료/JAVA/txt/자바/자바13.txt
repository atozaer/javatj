자 이제 연산자 마지막으로 조건연산자랑 비트연산자를 살펴보도록 하겠습니다. 

조건연산자는 이제껏 본적 없던 연산자의 종류가 되겠는데 3항 연산자에요 우리가 지금까지는 단항연산자 이항연산자까지는 봤는데 조건연산자는 3항연산자입니다. 항이 3개라는 뜻이죠 3항 연산자가 되는데 

어떻게 사용을 하시냐면 우리가 요 다음에 배울 조건문이 있는데 조건문의 축약 버전이라고 생각을 하시면 됩니다. 간단하게 표현할때 조건문을 간단하게 표현할때 사용할 수가 있습니다. 

조건식이 있고 조건식이 참이냐라고 물어보는거에요 조건식이 참이게 되면 결과1을 선택을 하고 그렇지 않으면 결과2가 반환되게 됩니다. 결과1과 결과2사이에 결과1과결과2사이에는 세미콜론이 아니고 

콜론을 써요 세미콜론은 문장의 끝이라고 했죠 그래서 중간에 쓰질 않습니다. 그래서 1이거나 2를 선택하게 되는데 조건식의 결과가 참이냐 거짓이냐에 따라서 선택이 됩니다. 

5가 3보다 크냐 묻는거죠 당연히 크죠 결과가 true가 되니까 num에는 10이 들어가게 되겠습니다. 요렇게 쓰면 연산자의 3항연산자의 장점은 간단한 조건식 if문을 쓰게 되는데 간단한 if문은 요 

3항연산자를 쓰면 간단하게 표현할수가 있어요 그런 장점이 있죠 그래서 종종 쓰게 됩니다. 눈에 익혀 두시구요 3항이라서 처음 보시는 분들도 있을 거고 눈에 안익을수도 있지만 아 요렇게 쓰는구나

이 중간에 콜론을 쓴다. 라는거 봐두시구요 저랑은 큰수 두개의 수를 입력을 받아서 큰수를 반환해주는 요런 예제를 같이 해보도록 하겠습니다. 

실습

1)package 생성 kr.or.kh13 

2)클레스생성 ContionTest

지금까지 입력받는거는 한번도 안해봤는데 사실 입력은 자바입출력은 자바 i/o라고 하는데 스트림이라는걸 써요 i/o스트림을 씁니다. 입출력용 스트림을 쓰는데 그거는 후반부에서 이야기를 할거구요 

근데 우리가 인제 중간중간에 입력받을 일들은 조금씩 있거든요  입력을 받기 위해서 간단히 쓸수있는 방법을 하나 소개해 드리고 하겠습니다.  어떤애가 있냐면요 Scanner 라는 애가 있어요 Scanner scanner=

사용을 하실때는 아직 객체를 안배우셨기 때문에 사용하는 방법을 설명을 드리고 이렇게 쓴다라고 말씀을 드릴게요 new하시고 Scanner라고 이젠 만드시는거에요 괄호안에다가  System.in이라고 쓰시는데  

시스템인이라고 쓰시는데 시스템인이라는 애가 뭐냐면 표준입력을 이야기를 합니다. 지금까지 출력을 시스템점 out이라고 섰었죠 시스템점 아웃은 표준출력이되거든요 그래서 이게 입력이 어디냐면 아래

Console화면에서 입력을 받게끔 그렇게 하는거구요 Scanner라는 객체는 자바에서 제공을 해주는거에요 어디있냐면 자바유틸이라는 패키지안에 들어있습니다. 스캐너 에러난곳에 마우스를 가져가면 목록이 

뜨는데 클릭을 해주시면 맨위에 inport라는 구문이 들어가요 요거하나 쓰기위해서 많은 이야기를 하는데 앞으로 종종 쓸거니까 요렇게 쓴다 라는걸 이해를 해주시고 import가 뭐냐 이것을 물어보실수가 있는데 

스캐너가 여기에 있는 이 라이브러리에 있는 놈이다. 라는 걸 알려주는 그런 역할을 하는  키워드라고 보시면 되겠습니다. 나중에 이제 객체를 하면 더 자세하게 말씀을 드릴거구요 오늘은 일단 요기까지 해서 

스캐너라는 애를 쓸수있다.  입력을 한번 받아볼려고 하는거니까 요렇게 말씀을 드릴게요 그래서 이렇게 입력을 받으실려면 scanner한다음에 이렇게 점하면 사용할수 있는것들이 죽나와요 그래서 우리가 인제

nextInt() 정수를 받을 건데 nextInt하시면 되는데 제가 입력받는거를 미리하는이유가 뭐냐면 입력받는거를 좀 늦게 했더니 강의할때 미리 입력받는거를 좀 알려주셨으면 좋겠다라는 이런 의견이 있어서 스캐너를 

사용하면 간단하게 입력을 받을수가 있어요 입출력 애기는 굉장히 긴 애기입니다. 사실은  그런데 그애기를 여기서 한꺼번에 할수는 없고 요렇게 애를 써서 입력을 받을수 있다. 라는것만 저희가 보고 들어가도록 할게요 

int num = scanner.nextInt(); 이렇게 해서 받았습니다. 라고 생각하고 num을 한번 이렇게 출력을 해볼게요 이렇게 하시면 결과는 아무것도 없구요 여기에서 보실게 뭐냐면 아래에 이렇게 빨간사각형으로 되어 있죠 

음 기게 run실행중이라는 거에요 사각형을 누르면 끝이납니다. 실행이 끝나는거구요 지금까지는 출력하는 부분만 있었기 때문에 쭉실행되고 끝났을 거에요 그런데 다시 실행해 보시면 아래사각형에서 뭔가 기다리고 

있죠 입력을 기다리고 있는 거에요 왜냐면 입력을 받겠다고 했으니까 콘솔창에 10을 키보드로 치면 입력받은 10이 이렇게 나오죠 요렇게 사용을 하시는 겁니다. 간단한 숫자 스트링 이런것들을 다 입력을 받으실수가 

있어요 스캐너 사용하는 방법은 좀더  무궁무진하지만 우리가 지금은 정수를 입력받는 방법만 알고 이제 어떤 거를 해볼거냐면 조건연산자를 쓸거잖아요 조건연산자를 통해서 두수를 입력을 받아서 그중에 더큰수를 

선택하는 조건연산자를 이용해서 구현을 해보도록 하겠습니다. 스캐너 이렇게 만들어 놨고 더 큰수를 선택을 할거니까 그 반환값을 max라고 하고요 숫자를 두개를 입력을 받을게요 두수를 입력 받아서 더 큰수를 

출력하세요\n 메시지를 작성하고 그리고서 숫자를 쓰게끔 int num1 = scanner.nextInt(); int num2 = scanner.nextInt(); 이렇게 받으시고 조금 햇깔리실수가 있으니까 입력1: 이라고 기다리는 상태로 좀 써주고 

입력2: 이렇게 기다리겠습니다. 자 그리고 나서 더 큰수 조건연산자를 쓰는거에요 max = (num1 > num2) ? num1: num2; 라고 써있는수에  num1이 num2보다 크냐 같은경우에는 아무거나선택해도 상관없으니까요 

참이면 num1을 선택하고 그렇지 않으면 num2를 선택해라 요런 애기죠 그죠 그래서 System.out.println(max);출력을 할게요 그리고 나서 실행을 해보면 두수를 입력받아서 두수를 입력받아서 더 큰수를 출력하세요 

이렇게 되어 있죠 제가 10을 넣고 20을 딱넣으면 출력되는건 최대값 20이렇게 나오죠 그래서 잠깐 스캐너라는걸 어떻게 쓰는지도 살펴봤고 조건연산자 사용하는 방법도 알아봤습니다. 

간단하게 (num1>num2)여기가 조건을 체크하는거구요 앞에 결과가 true가 되면 num1선택이되고 그렇지 않으면 num2가 선택이 된다. 

자 이번에는 비트연산자를 살펴보도록 할게요 

비트연산자는 비트에 대한 연산을 말그대로 비트에 대한 연산을 하는건데요 (~)단항연산자도 있고 이항연산자도 있고 그렇습니다.  이항연산자인경우에는 논리곱(&) 논리합처럼( | ) 두 이항연산자인 경우에는 

비트단위의 AND 두개의 비트가 둘다 1인경우에만 1이 반환이 되고 둘중에 하나라도 0인경우에는 0이 반환되는 이게 AND연산자구요 비트OR는 비트단위로 둘중에 하나만 1이면 1이 반환되고 둘중에 비트가 

둘다 0인경우에만 0이 반환되는 그런 연산자가 되겠습니다.  ~(앞에있는) 거는 반전이라고  해서요 비트를 뒤집는 거에요 0은 1 1은 0 이렇게 애기를 하고 밑에 삿같모양으로 돼 있는거^ 우리가 컴퓨터에서 보면 

키보드 6번 위에 있는 XOR익스클리시브오아라고 해요 애는 어떤 연산자냐면 두개의 비트가 서로 다른경우에만 1을 반환합니다. 두개의 비트가 같은 경우에는 0이 반환되는 이런 연산자가 되겠습니다. 

그리고 >> << 이게 쉬프트 연산자라고 하는데 비트를 움직이는거에요 왼쪽으로 두개돼 있는 거는 왼쪽 shift라고 하구요 오른쪽으로 두개돼 있는 거는 라이트쉬프트가 됩니다. 라이트쉬프트에 세개가 있는 

>>>연산자가 있는데 이거는 똑같이 두개 있는 연산자랑 동일한데 단위에있는거는 부호비트가 같이 따라가는 거고 밑에는 채워지는 비트가 부호랑 상관없이 영으로 채워라 라고 합니다. 이런 연산이 있는데 

애를 어디서 쓰느냐 라고 하면 우리가 프로그램할때 비트연산자를 많이 쓰는거는 아니에요 특히 자바프로그래밍 같은 경우에는 비트연산자를 그렇게 많이 쓰지는 않지만 좀 더 빠른 오퍼레이션을 할 필요가 

있을 때 비트연산자가 사용되기도 합니다. 특정 비트를 꺼내기 위해서 우리가 마스킹이라고 이야기를 하는데 여기 보시면 00001111이렇게 되어 있다는 거죠 우리가 5라는 수를 이야기를 해볼까요 8비트로만 

생각을 해보겠습니다. 00000101 이게 5죠 5가 됩니다. 요 하위 4개 비트의 상태를 알고 싶다 앞에는 상관없구요 뒤에 4개비트를 1로 한다음에  &(논리곱)을 하면 뒤에 비트가 그대로 나오겠죠 이런경우 우리가 

인제 특정 비트를 가리고 나머지 비트를 사용하는 이걸 마스킹이라고 하거든요 요렇게 쓸수가 있어요 이비트만 꺼내는거죠 이비트만 꺼버리고 싶다 없애버리고 싶다 라고 하면 맨뒤4비트를 0000하고 &(논리곱)을 

해버리면 0101비트가 0으로 다 채워지겠죠 비트를 켜거나 비트를 끄다 할때 사용하실수가 있구요  모든 비트가 0또는 1 1또는 0으로 반전하고 싶다라고 했을때 비트토글이라고 이야기를 하는데 요럴때도 사용하

실수가 있습니다. 어 실제적으로 비트의 연산이 이루어지고 그로 인한 연산의 결과를 얻을수가 있는데 제가 밑에다가 넣어놓은 예제는 5하고 10을 두개의 수를 and(&) or( | ) xor(^) not(~)을 해봤어요 

비트를 직접 shift를 해봤습니다. 이거를 보시면 잠깐 생각을 해보고 코딩을 할께요 그러면 5을 다시 나타내면 0000 0101 이게 5가 되는거구요 10은 0000 1010 요건 5고 10이라는거죠 두개를 &를 해볼게요 

비트가 같을때만 1이나온다고 그랬죠 그럼 모두가 0일꺼에요 0000 0000 5하고 10을 and(&)를 하면 결과가 0일거구요 | or를 해보면 두개의 비트가 0일때만 0이 나온다 0000 1111이 나오겠네요 요거는 10진수로 

이야기하면 15가 나옵니다. ^ 두개의 비트가 같으면 0 다르면 1이라고 했잖아요 0000 1111 이 나오겠네요 그러면 ^도 15에요  ~not을 하게되면 ~num1을 not을 했죠 num1이 5데 0000 0101이라는 거죠 

이거를 not을 하게되면 1111 1010이 되는 거구요 요거는 음수에요 음수 not을 하면 음수가 나올겁니다. 음의 보수를 다시 취해서 값을 찾아보면 우리가 아직 보수 취하는거를 애기를 안했기 때문에 일단 

이게 음수다 ~num1 밑에 왼쪽<<shift가 있구요 왼쪽shift를 하게 되면 생각을 해봅시다. 5가 있다는 거죠 0000 0101 요거를 한칸만 왼쪽으로 보낼께요 <<1 한칸만 왼쪽으로 보낼게요 앞에 있는 비트는 

트렁케이트된다고 하는데 (버려져요) 0000 1010(10)이에요 5에서 시작했다면 <<2비트를 밀은 상태입니다. 0001 0100(20)이 됩니다.  10 5x2의 1승 5x2의 2승이 됩니다. 그래서 이 비트가 옮겨진 개수만큼

2의 엔승으로 곱해져서 숫자가 만들어지는거죠 이게 왼쪽 shift의 특징입니다. >>오른쪽으로 옮기게 되면 그 반대겠죠 /2나누기 2가 만들어져요 그래서 왼쪽으로 비트를 밀게되면 

비트가 큰수쪽으로 이동을 하잖아요 2의 n승만큼 늘어나니까 쉬프트한 비트수의 2의 n승만큼곱배지는거고  오른쪽으로 보내면 숫자가 점점 작아지죠 shift한 수의  2의 n승만큼 나누기가 된다. 라는거를 

이해하시면 되겠습니다. 같이 프로그램하면서 아까 연산했던 결과가 맞는지도 한번 보도록 할게요 

실습

이클립스여시고 클레스 BitOperationTest를 생성하고 main함수를 작성한다. int num1=5; int num2=10; num1|num2출력하고 num1&num2출력하고 num1^num2출력하고~num1출력한다.

그 다음에 shift를 한번해 볼게요 num1<<2출력한다. num1을 출력한다. 가끔 혼동하시는 게 있는데  왼쪽으로 밀린값 자체는 20이 되요 곱하기 4가 되는거죠 2의2승이니까 5곱하기4하면 20이되는데

num1을 출력을 해보면 num1의 값은 변하지 않습니다. 이거는 뭐랑 같냐면 이게 이 값 자체를 바꾸는게 아니라 num1이라고 하는 값을 복사해 와서 그걸 두비트를 민거에요 전 그럼 이값이 바뀌었으면 

좋겠는데요 생각을 하시면 num1<<=2대입연산자를 반드시 쓰셔야 해요 그냥 값을 부호를 바꾸는 부호연산자를 쓴다거나 비트연산자를 쓴다고 해서 그 값 자체가 변하는 건 아닙니다. 변수의 값을 

바꾸려면 대입연산자를 쓰셔야 돼요 대입연산자를 쓰시게 되면 num1<<2이때는 20이 출력이 된거구요 이땐 아직 안바뀌었다고 그랬죠  num1<<=2이렇게 하면 바뀐 num1이 되겠죠 정말 바꼈나 

num1을 출력하면 바뀐 20이 되죠 <<=2 요게 복합대입연산자죠 저번에 복합대입연산자 말씀드릴때 복합대입연산자가 비트대입연산자와 같이 쓰인다. 그 상황을 말씀을 드릴수가 있습니다. 

그럼 오른쪽으로 하나만 밀어볼까요 num1 >>1 10이나오죠 2의 n승만큼 곱해지거나 나누어지는게 쉬프트연산자다 말씀을 드렸습니다. 

연산자우선순위가 마지막으로 나왔는데 우리가 지금까지 연산자들을 쭉 봤고 게네들을 다 써봤는데 연산자간에도 우선순위가 있어요 대표적으로 산술연산자가 더하기 빼기보다 곱하기 나누기가 더 높다

라는 걸 여러분들이 아실거고 전반적으로 봤을때 ( )가로연산자가 대단히우선순위가 높습니다. 단항연산자 항이 적을수록 우선순위가 높습니다. 그다음에 이항연산자 그다음에 조건연산자 이렇게 나와있고

처음에 대입연산자(어싸인먼트) 말씀을 드릴때 대입연산자우선순위는 상당히 낮다라고 말씀을 드렸죠 주로 오른쪽항에 있는 다 연산이 끝이 나고 그결과를 왼쪽항에다가 LVALUE에다가 대입시킬때 대입연산자를 

사용하게 되거든요 대입연산자우선순위가 낮다라는거 쭉 보시면 될겁니다. 이거를 외울필요는 없으시고 쓰다보면 몸으로 다익숙해 지는건데 요런것들만 주의를 말씀을 드리면 연산자 우선순위는 분명합니다. 

분명하기 때문에 표를 보시면 산술연산자가 관계연산자보다 당연히 우선순위가 높아요 높은데 그렇다고 해서 가로를 ( )를 빼고 쓰면 가독성은 별로 안좋습니다. 그래서 더하기나 빼기할 내용이 있고 그 내용을 

어떤수와 비교를 한다고 하면 가로( )를 쳐주시는게 훨씬 가독성이 좋다는 거죠 음 예를 들어서 전에 했던 예제중에 boolean value = (num1+10>10) || ((i=i+2)<10);  num1+10을 더한게 뒤에 10보다 크냐고 물어보는거에요 

요럴때 가로를 쓰지 않아도 혼란스럽지는 않죠 그런데 애네의 우선순위가 높으니까  boolean value = ((num1+10)>10) || ((i=i+2)<10); 가로를 써주면 좀 덜 혼란스럽죠 제가 말씀드리는거는 우리가 앞으로 코딩

을 계속 할건데 코딩 할때 중요한게 가독성이에요 내가 짠 코드 뿐만이 아니라 내가 짠 코드를 우리팀원들도 볼거고 다른사람이 가져다 쓰기도 합니다. 그리고 내가 나중에도 볼거잖아요 가독성 좋은 코드를 

만드는게 굉장히 중요합니다. 뒤에 제어문이 나오면 이런 잔소리 아닌 잔소를 또 할겁니다. 그래서 가독성 좋은 코드를 만드는 게 중요하다 라고 말씀을 드리는거구요 이번강의까지 연산자애기는 다끝났고 다음에 

제어문을 말씀드리도록 하겠습니다. 








 


