자 이제까지 변수라는 거에 대해서 말씀을 드렸는데 프로그램을 하다보면 변하지 않는수가 필요할때도 있어요 

대부분은 변하는 수들로 우리가 프로그램 변수를 많이 써서 프로그램을 많이 하는데 변하지 않는수 고정된 수가 필요할 경우도 있죠 

만약에 일년은 12달이다. 12달인데 10이라는 계속 반복해서 쓰는거는 의미는 있지만 가독성이 떨어지죠 그죠 그래서 그런경우에 

원주율같은 경우에 3.14다 라고 했을때 그런 값들은 변하지 않습니다. 그죠 우리학교에 학급이 10학급이다. 10학급이다라고 했으면 

그 10학급은 왠만해서는 어느해에 학생이 확 많이 들어오지 않는 이상은 그 학년의 학급은 왠만해서는 어느해에 확 들어오지 않는 이상은 

그 학년의 학급은 크게 변하지 않습니다. 그런식으로 변하지 않는 숫자들이 반복해서 프로그램에서 쓰일때 우리는 그것들을 상수로 선언해서 쓸수가 있어요

상수로 선언을 할때는 앞에다가 final이라는 예약어를 씁니다. final이라는 예약어를 써서 상수를 선언을 하시구요 상수를 선언해서 쓰실때는 이값을 한번 선언을 하고 

값을 입력을 하게 되면 애는 중간에 바꿀수가 없습니다. 파이널이라는 의미가 마지막,최종,종단의 라는 의미죠 파이널이라는 키워드가  메소드에도쓰고 클레스에도 쓸수가 있어요 

다 똑같은 의미로 마지막이다 변하지 않는다. 이런의미로 사용할수가 있습니다. 변하지않는값을 반복적으로 사용할때 상수를 쓴다고 말씀을 드렸는데 final예약어를 이용해서 

선언을 하시고 이게 선언과 동시에 대부분은 초기화를 해요 그러니까 예제에서 보시듯이 맥스넘은 100이다. 우리가 이 프로그램에서 맥스넘이라고 지정하는것은 100이다. 

라고 선언과 동시에 초기화를 많이 하는데 가끔은 선언만 해놓고 초기화를 안하는경우도 있습니다. 그런데 초기화를 변수를 값을 넣지 않고 쓸수는 없어요 그러니깐은 MAX_NUM

에다가 중간에라도 사용하기전에 맥스넘은 얼마짜리다. 라고 값을 지정하고 쓰시면 됩니다. 그리고 이렇게 한번 초기화를 했으면 나중에 바꿀수가 없어요  상수라는게 변하지 않는 수라고 말씀드렸죠 

그래서 바꿀수 없습니다. 바꿀수 없구요 그리고 여기에 보시면 다른변수들과 차별화를 하기 위해서 상수같은 경우는 대문자를 많이 씁니다. 긴 경우에는 언더바를 쓰기도 하구요 

대문자로 상수를 많이 표현한다라는걸 알아두셨으면 좋겠습니다. 요 간단한 예제니까 저와 함께 해볼까요 

실습

이클립스 여시구요 ->package kr.or.kh10생성하고->클래스이름생성 ConstrantTest main제작하기->

인트 MAX_NUM=100이다 대문자로썼다고 해서 상수는 아니에요 MAX_NUM=20;이다 라고 해도 이경우는 변할수 있습니다. 그냥 변수처럼 쓰는거죠 변수이름이 대문자로 쓰는경우는 흔한건 아니지만 

앞에다가 키워드로 final 이렇게 써주면 MAX_NUM이라는 변수에 에러가 납니다. 이미 이 MAX_NUM이 상수이기 때문에 한번 정해진 값을 바꿀수는 없다.  두번째 줄에 final int MIN_NUM;선언을 하고 

상수는 값을 대입하지는 않고 주로 값을 가져와서 쓰니까 우리가 이런거를 참조한다. 레퍼런스한다. 라고 이야기 하는데 값을 가져와서 제가 출력을 할거에요 MIN_NUM에서 오류가 나죠 사용하시기 전에는 

반드시 상수는 값을 지정을 해줘야 됩니다.  상수의 장점에 대해서 잠깐 말씀을 드렸는데 이런경우를 한번 생각을 해볼게요 우리학교 학급에 학생이  30명이었어요 우리 학급에 대한 프로그램을 할려고 하는데 

30명에 대한 프로그램을 할려다 보니까 계속 30이라는 계속 숫자를 프로그램내에서 섰어야 됩니다. 30이라는 숫자를 계속섰는데 이거를 계속쓰면 나중에 이 30의 의미도 모르겠고 그래서 상수로 선언을 

한거죠 final int STUDENT_NUM=30; 자 이렇게 선언을 하면 장점은 뭐냐면 오류가 날일이 없죠  항상 우리반은 30명이었으니까 30명으로해서 STUDENT_NUM이라는 섰을때 다른값을 대입을 못하고 

그런데 어느날 다섯명이 전학을 왔어요 그래가지고 35명이 된거죠 35명이 됐으면 만약에 프로그램에다 30이라는 숫자를 다 하드코딩을 했다라고 하면  파인드 올을 이용해서 30을 찾아서 35로 다 변경을 

해줘야 되는거죠 근데 이경우에는 선언한데만 35로 바꾸어서 재컴파일을 하면 사용할수가 있잖아요 그래서 상수를 쓰는 장점이 변하지 않는 값을 반복하여 사용할때 의미있는 문자로 인식하기 쉽고 그냥 

숫자로만 쓰이는것 보다  STUDENT_NUM=35로 쓰는게 가독성 제가 앞으로 수업할때 가독성의 중요성에 대해서 계속 이야기할거거든요 변하더라도 선언한 부분만 변경하면 되므로 여러부분을 수정할  필요가 없다.


자 이번에는 리터럴이라는 용어가 나왔어요  그 전에 제가 몇번을 말씀을 드렸던 그런 내용이긴 합니다. 

프로그램에서 사용하는 문자나 숫자 어떤 논리값  int num=10; 10이라는 숫자가 어서 똥 튀어나온것이 아니라 

이미 10이라는 숫자가 어디에 4바이트로 자리를 잡고 있고 이 10이라는 숫자가 num이라는 메모리 4바이트로 잡히겠죠 10이라는 숫자가 로드돼서 복사되서 num이라는 공간에 복사가 된다. 

10이라는 숫자가 없어지진 않아요 계속있습니다. 계속있는데 num이라는 공간에 복사된다. 

프로그램에서 쓰는 값들 int num=10; 10(literal)실제값=리터럴이라고 이야기를 해요 리터럴을 사용하기 위해서 정수같은 경우는 모든 정수형리터럴 int로 실수는 double로 저장을 한다. 

범위가 넘어가는 경우 12345678900처럼 긴수는 그 리터럴이 저장되기 위해는 4바이트보다 큰  메모리가 필요하죠 대문자L이나 소문자l을 쓰시면 된다 아무래도 대문자가 소문자 1과 햇깔리니까

대문자가 좋다. 상수풀이라는 개념이 있는데 여기에대해서 말씀을 드릴게요 많은 분들이 이렇게 생각을 하겠죠 아 그러면 저 숫자는 언제 메모리에 잡히나요 언제 메모리에 위치를 가지게 되나요 생각을 할수가 있는데 

하드디스크에 프로그램이 있구요 그프로그램을 실행을 시키면 하드디스크에 있는 프로그램이 메모리에 로드(load)가 되는거구요 이 로드되는 시점에 이 프로그램안에 있는 자료중에 일부는 메모리를 먼저 잡아요 

실행이 되면서 메모리를 할당 받는 그런애들이 있구요 그게 아니라 실행과 상관없이 이 프로그램이 여러줄로 쭉 있으면 실행되는 순간 메모리를 할당받거나 하는 경우가 있는 반면에 그게 아니고 그냥 애가 올라왔다는 

이유만으로 프로그램이 메모리에 로드됐다는 이유만으로 그 순간 어떤 영역을 잡는 애들이 있어요 개네들이 주로 상수, 나중에 배울 static변수 이런 애들입니다. 그리고 우리가 상수중에 이런값들을 liteal이라고 하죠 

이런것들이 자리를 잡게 되구요 요런것들이 자리를 잡는 영역을 여러가지 용어로 애기를 하는데 Data 영역 Constant pool (상수영역) 이기도 합니다. 애가 말씀드리는 리터럴은 제가 상수풀이라는 용어를 섰는데 

메모리에 자리를 잡게 되구요 메모리에 자리를 잡히면 애는 언제 해제가 되냐면 프로그램의 시작이 다 끝나고 애가 메모리에서 언로드될때 사라지게 됩니다. 이런것들을 리터럴이라고 한다. 

이런 개념은 자바만 있는게 아니라 다른언어들도 다 비슷하게 운영이 되고 있습니다. 마지막으로 형변환에 대해서 이야기를 할텐데요 형변환은 뭐냐면 우리가 프로그램을 쓰다가 보면 모든 자료형이 동일한 크기는 

아니에요 모든 자료형이 동일한 크기는 아니에요 연산을 할려고 보는데  내가 이변수하고 이변수를 연산을 할려고 보니까 애는 int고 애는 float일수도 있고요 애는 int고 애는 long일수도 있고 이렇게 크기가 다르다던가

아니면 정수하고 실수는 아예 표현방식이 메모리안에 다르다던가 일수 있습니다. 그런경우에 형을 맞춰서 연산을 해야되요 수행을 해야지  다른형끼리 연산을 할수 없습니다. 실수와정수를 더할순없어요 그죠 

한쪽이 정수가 실수가 되거나  실수가 정수가 되거나 둘중에 하나가 맞춰서 둘다정수거나 둘다실수가 되야지 연산이 가능하지 그상태로는 연산을 할수가 없습니다. 

그래서 형변환이라는게 일어날수 밖에 없는데 서로 다른 자료형 간에 연산들의 수행을 위해 하나의 자료형으로 통일하는것 형변환의 종류에 크게 두가지가 있어요 묶시적으로 일어나는 형변환 아무런 프로그래머가 

개입하지 않아도 자동으로 형변환이 된다는거죠 명시적형변환 프로그래머가 프로그래밍안에 강제적으로 타입캐스팅을 합니다. 강제형변환이라고 합니다. 이렇게 두가지가 있습니다. 

자동으로 된다는 애기는 결국 무슨이야기냐면 그렇게 자동으로 돼도 문제가 되지 않는다는 거구요 강제적으로 한다는 애기는 이게 이렇게 됐을때 어떤 손실이나 문제가 생겨도 그건 프로그래머가 강제로 형변환을 

시켰기 때문에 프로그래머의 책임인거죠 그래서 묵시적인 형변환이 일어나는거를 보면 작은 크기에서 큰자료형으로 형변환이 이루어지는것 가령 애를 들어서 int 자료형이 있는데 long타입에 넣는다 이건 아무 

문제가 되지 않습니다. 왜냐면 4바이트의 자료가 8바이트의 자료에 들어가는거기 때문에 자료의 유실이 일어나지 않습니다. 그런식으로 작은메모리에서 큰메모리로 이동되는 경우에는 형변환은 큰걸로 이루어지게 됩니다. 

덜 정밀한 자료형에서 더 정밀한 자료형으로 형변환은 자동으로 이루어짐 덜정밀하다는거는 정수를 생각하시면 되구요 더 정밀하는다는 것은 실수입니다. 실수같은 경우가 정수가 실수로 형변환이 되면 실수부가 영으로

표현이 되면 된거죠 2.0 3.0 으로 표현이 되면 되니까 그때는 자료의 유실이 없어요 그런데 1.2라는 실수가 있는데  이걸 int에게 담아라 라고 하면 애는 정수부는 표현할수 있지만 실수부를 표현할수 있는 메모리 구조는 

아닙니다. 그래서 .2가 짤려버리게 되죠 요렇게 형변환이 될때는 강제적으로 캐스팅을 해줘야 합니다. 바이트는 한바이트인데 바이트를 가지고 int에다가 집어넣은 거죠 생각을 해보시면 1바이트에서 4바이트니까  이렇게 

들어갈때는 아무 문제가 될리가 없습니다.  요건 자동형변환이 되겠죠 20이 iNum에 들어간거죠 iNum1에서 iNum1이 플롯트로 바뀌어서  fNum으로 들어가면 되는거죠 요때도 아무런 문제가 되지 않습니다. 

iNum 10이 4바이트를 한바이트에 집어넣는거죠 이때는 빨간줄이 나올거에요 이클립스에서오류가 나올거구요 이때 앞에다가 나는 바이트로 넣겠다. 프로그래머가 명시적으로 이렇게 써주는거를 타입캐스팅이라고 합니다. 

강제형변환이 되겠죠 그래서 요렇게 했을때 자료가 유실된다 라고 해도 상관이 없다.  그런 의미구요 더블도 3.14데 이걸 강제적으로 인트로 바꾸어서 넣게 되면 나머지 요 실수부분 소수점 이하 부분이 잘린다. 자료의 유실이 

일어난다. 라는거를 명시적으로 표현을 한거죠 

실습

형변환에 대해서 잠깐 보겠습니다. 

byte는 수의표현범위가 음수는 -128+127까지의 숫자를 표현을 할수가 있습니다. 그럼 여기서 요렇게 바꾸어 볼게요 바이트의 표현범위가 넘어간 거고 프로그래머가 이렇게 넣기 때문에 프로그래머책임인거죠 

10일때는 상관이 없겠죠 바이트에 들어갈수 없는 값을 넣으면 -1이상한 값이 나오죠 자료에 문제가 생기는 거고 연산을 하면서 형변환했을때 내가 생각하지않은 방식으로 연산이 될수 있습니다. 


 









